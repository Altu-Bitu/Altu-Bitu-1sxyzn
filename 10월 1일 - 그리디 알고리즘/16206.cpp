#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

bool cmp(const int &a, const int &b) { //케이크 길이 정렬하는 함수
    if (a % 10 == 0 && b % 10 == 0) //둘 다 나누어 떨어지면 짧은 것부터
        return a < b; //같은 조건일 경우 오름차순으로
    return a % 10 == 0; //나누어떨어지는 게 먼저 오도록 정렬
}

//롤케이크 자르는 함수
int cutCakeRoll(int n, int m, vector<int> &cake) { // 총 갯수, 자르는 최대 횟수, 케이크를 매개변수로
    int ans = 0; // 길이 10인 롤케이크 갯수 저장할 변수

    for (int i = 0; i < n; i++) { //전체 케이크를 다 탐색하기
        int cut = cake[i] / 10; //자르는 횟수
        if (cake[i] % 10 == 0) //케이크가 10으로 나누어 떨어진다면
            cut--; //자르는 횟수 -1 하기
        if (cut <= m) { //모두 자르기 가능한 경우
            m -= cut; //자를 수 있는 최대 횟수에서 자르는 횟수 빼주기
            ans += cake[i] / 10; //길이10인 롤케이크 갯수 누적해서 더해주기
        } else { //다 못자르는 경우 -> 한 번 자를 때 1개씩 나오므로 m 더함
            ans += m; // 자를 수 있는 만큼만 누적해서 합해주기
            break; // for문 종료
        }
    }

    return ans; //길이가 10인 롤케이크의 갯수 최댓값 리턴
}

/**
 * 길이가 10인 롤케이크 개수의 최댓값을 구하는 문제
 * 길이가 10이상인 롤케이크를 잘라보자. 기본적으로 한 번 자르면 1개씩 나오게 된다.
 * 이때, 10으로 나누어 떨어지는 길이를 먼저 잘라야 한다. (ex. 15를 한 번 자르면 1개가 생기지만, 20을 한 번 자르면 2개가 생김)
 * 10으로 나누어 떨어지는 길이 중에서도, 작은 길이를 먼저 잘라야 한다. (ex. 20을 한 번 자르면 2개가 생기지만, 30을 한 번 자르면 1개가 생김)
 * 10으로 나누어 떨어지지 않는 다른 수끼리는 순서가 상관 없다.
 */

int main() {
    int n, m;//n은 롤케이크의 갯수, m은 자를 수 있는 최대 횟수

    //입력
    cin >> n >> m; //롤케이크 갯수와 자를 수 있는 최대 횟수 입력
    vector<int> cake(n, 0); //케이크 생성
    for (int i = 0; i < n; i++) //롤케이크의 갯수 만큼 길이를 받는다
        cin >> cake[i]; //케이크 길이 입력

    //연산
    sort(cake.begin(), cake.end(), cmp); //10의 배수인 것 (나누어 떨어지는 것) 먼저 정렬하는 함수

    //연산 & 출력
    cout << cutCakeRoll(n, m, cake) << '\n'; //케이크 자르고, 길이 10인 롤케이크 갯수 최댓값 리턴받아 출력

    return 0; //프로그램 종료
}
